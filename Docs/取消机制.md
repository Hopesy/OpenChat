# OpenChat 取消机制完整指南

> 聊天请求取消机制的原理、实现和常见问题全面解析

---

## 一、核心原理

### 1.1 取消机制架构

```
用户操作（点击取消/快速发送/超时）
    ↓
ChatService.Cancel() / 自动取消
    ↓
_cancellationTokenSource?.Cancel()  // 发出取消信号
    ↓
CancellationToken 传播到 API 调用
    ↓
StreamCompletionAsync 抛出 TaskCanceledException
    ↓
ChatPage 捕获异常并回滚（恢复输入框，移除消息）
```

### 1.2 三层取消控制

```
【层级 1：用户手动取消】
    点击"取消"按钮 / Ctrl+Shift+Enter
    → ChatService.Cancel()

【层级 2：自动取消旧请求】
    快速发送新消息
    → _cancellationTokenSource?.Cancel()（自动取消上一次）

【层级 3：超时自动取消】
    30 秒无响应片段
    → completionTaskCancellation.Cancel()
```

---

## 二、关键实现

### 2.1 ChatService 核心代码

```csharp
public class ChatService
{
    // 【单实例】维护一个取消令牌源
    private CancellationTokenSource? _cancellationTokenSource;
    
    public Task<ChatDialogue> ChatAsync(Guid sessionId, string message, Action<string> messageHandler)
    {
        // 【步骤 1】取消旧请求（第一次为 null，不执行）
        _cancellationTokenSource?.Cancel();
        
        // 【步骤 2】创建新的取消令牌源
        _cancellationTokenSource = new CancellationTokenSource();
        
        // 【步骤 3】传递令牌给核心方法
        return ChatCoreAsync(sessionId, message, messageHandler, _cancellationTokenSource.Token);
    }
    
    // 用户手动取消
    public void Cancel()
    {
        _cancellationTokenSource?.Cancel();
    }
}
```

### 2.2 超时检测机制

```csharp
private async Task<ChatDialogue> ChatCoreAsync(..., CancellationToken token)
{
    var lastTime = DateTime.Now;  // 记录上次响应时间
    var completionTaskCancellation = CancellationTokenSource.CreateLinkedTokenSource(token);
    
    // 【任务 1】API 流式调用
    Task completionTask = client.ChatEndpoint.StreamCompletionAsync(
        request,
        response => {
            // 每收到响应片段更新时间
            messageHandler.Invoke(content);
            lastTime = DateTime.Now;
        },
        completionTaskCancellation.Token
    );
    
    // 【任务 2】超时检测（100ms 轮询间隔）
    var cancelTask = Task.Run(async () =>
    {
        var timeout = TimeSpan.FromMilliseconds(ApiTimeout);  // 默认 30 秒
        
        while (!completionTask.IsCompleted)
        {
            await Task.Delay(100);  // 每 100ms 检查一次
            
            if (DateTime.Now - lastTime > timeout)
            {
                completionTaskCancellation.Cancel();  // 触发取消
                throw new TimeoutException();
            }
        }
    });
    
    await Task.WhenAll(completionTask, cancelTask);
}
```

### 2.3 UI 层异常处理

```csharp
[RelayCommand]
public async Task ChatAsync()
{
    var requestMsg = new ChatMessageModel("user", input);
    var responseMsg = new ChatMessageModel("assistant", string.Empty);
    
    ViewModel.Messages.Add(requestMsg);
    
    try
    {
        var dialogue = await ChatService.ChatAsync(SessionId, input, content => {
            responseMsg.Content = content;
            if (!responseAdded) {
                Dispatcher.Invoke(() => ViewModel.Messages.Add(responseMsg));
            }
        });
        
        // 保存到数据库
        requestMsg.Storage = dialogue.Ask;
        responseMsg.Storage = dialogue.Answer;
    }
    catch (TaskCanceledException)
    {
        // 回滚：移除消息，恢复输入框
        ViewModel.Messages.Remove(requestMsg);
        ViewModel.Messages.Remove(responseMsg);
        ViewModel.InputBoxText = input;
    }
}
```

---

## 三、常见问题解答

### Q1: 第一次请求是否受 `?.Cancel()` 影响？

**答：不会。** 第一次调用时 `_cancellationTokenSource` 为 `null`，`?.` 运算符不会执行 `Cancel()`。

```csharp
// 第一次请求
_cancellationTokenSource = null;              // 初始值
_cancellationTokenSource?.Cancel();           // 不执行
_cancellationTokenSource = new ...();         // 创建新的 CTS #1

// 第二次请求（第一次未完成）
_cancellationTokenSource?.Cancel();           // 执行，取消 CTS #1
_cancellationTokenSource = new ...();         // 创建新的 CTS #2
```

### Q2: 为什么 `Task.Delay(100)` 是 100 毫秒？

**答：性能和及时性的最佳平衡点。**

| 间隔     | 30秒超时检查次数 | CPU占用 | 超时误差  | 评价       |
|----------|------------------|---------|-----------|------------|
| 1ms      | 30,000 次        | 高      | ≤1ms      | 过度检查   |
| 100ms    | 300 次           | 低      | ≤100ms    | **最佳** ✅ |
| 1000ms   | 30 次            | 极低    | ≤1000ms   | 反应慢     |

**实际效果**：
- 超时设置 30.000 秒
- 检测到超时最多 30.100 秒
- 误差 100ms（0.33%），用户无感知

### Q3: 已完成任务再次调用 `Cancel()` 是否安全？

**答：完全安全，无副作用。**

```csharp
// 场景：第一次请求已完成，发起第二次请求
[T0]   用户发送 "你好" → 创建 CTS #1 → 任务开始
[T5]   任务完成 ✅ （CTS #1 仍存在）
[T10]  用户发送 "再见"
       ├─ CTS #1.Cancel() → 只改变内部状态，不影响已完成任务
       ├─ 创建 CTS #2
       └─ 新任务使用 CTS #2（与 CTS #1 完全独立）
```

**关键点**：
- `Cancel()` 是幂等的（多次调用安全）
- 新旧 Token 完全独立
- 已完成任务不再监听取消信号

### Q4: 为什么不用 `CancelAfter()` 简化超时检测？

**答：`CancelAfter()` 是整体超时，不是响应片段超时。**

```csharp
// 方案 A：CancelAfter（不合适）
cts.CancelAfter(TimeSpan.FromSeconds(30));
// 问题：30 秒内必须完成整个请求
// AI 响应 2 分钟 → 被取消（即使一直有响应）

// 方案 B：轮询检测（当前方案）
while (!task.IsCompleted) {
    await Task.Delay(100);
    if (DateTime.Now - lastTime > 30s) Cancel();
}
// 优点：30 秒无新响应片段才超时
// AI 每 5 秒一个片段，持续 2 分钟 → 正常 ✅
```

---

## 四、完整时序图

```
时间    用户操作              系统状态                取消令牌状态
──────────────────────────────────────────────────────────────────
[T0]    点击"发送"            创建 CTS #1             Token 正常
[T1]    AI 正在响应...        流式回调持续触发         Token 正常
[T2]    点击"取消"            Cancel() 被调用          Token 已取消
[T3]    ────────            API 抛出异常             异常被捕获
[T4]    看到消息被移除        Rollback 执行           恢复输入框
[T5]    可以重新输入          等待下一次发送           准备新 CTS
```

---

## 五、典型场景

### 场景 1：快速连续发送（自动取消旧请求）

```
[T0]   发送 "你好" → CTS #1 → API 调用中
[T0.5] 发送 "再见" → 
       ├─ Cancel CTS #1（自动）
       ├─ 任务 #1 被取消
       ├─ 创建 CTS #2
       └─ 任务 #2 开始

结果：只有最新请求在运行 ✅
```

### 场景 2：超时自动取消

```
[T0]   API 调用开始 → lastTime = T0
[T5]   收到片段 "你好" → lastTime = T5
[T35]  30 秒无新片段 → 检测超时
       ├─ completionTaskCancellation.Cancel()
       ├─ 抛出 TimeoutException
       └─ Rollback 执行

结果：超时保护生效 ✅
```

### 场景 3：正常完成后发新请求

```
[T0]   发送 "你好" → CTS #1
[T5]   任务 #1 完成 ✅
[T10]  发送 "再见" →
       ├─ Cancel CTS #1（无影响，任务已完成）
       ├─ 创建 CTS #2
       └─ 任务 #2 开始

结果：两次请求都成功，互不干扰 ✅
```

---

## 六、设计优势

### 1. 简洁性

```csharp
// 无需复杂状态检查
_cancellationTokenSource?.Cancel();  // 简单直接
_cancellationTokenSource = new CancellationTokenSource();
```

### 2. 健壮性

```csharp
// 自动处理所有边界情况
?.Cancel()  // null 安全
Cancel()    // 幂等（多次调用安全）
            // 已完成任务无影响
```

### 3. 用户体验

```csharp
// 回滚机制
ViewModel.Messages.Remove(requestMsg);      // 移除消息
ViewModel.InputBoxText = input;             // 恢复输入（不丢失）
```

---

## 七、最佳实践

### 7.1 代码模式

```csharp
// 服务层：管理取消令牌
private CancellationTokenSource? _cts;

public Task DoAsync()
{
    _cts?.Cancel();              // 取消旧的
    _cts = new ...();            // 创建新的
    return DoCoreAsync(_cts.Token);
}

// UI 层：捕获异常回滚
try {
    await service.DoAsync();
} catch (TaskCanceledException) {
    Rollback();
}
```

### 7.2 调试技巧

```csharp
// 添加日志
Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Cancel 被调用");

// 关键断点位置
_cancellationTokenSource?.Cancel();  // ← 断点 1
catch (TaskCanceledException)        // ← 断点 2
if (DateTime.Now - lastTime > timeout)  // ← 断点 3
```

### 7.3 注意事项

```csharp
// ❌ 不推荐：复杂的状态检查
if (_currentTask?.IsCompleted == false) {
    _cts?.Cancel();
    await _currentTask;
}

// ✅ 推荐：简单的无条件取消
_cts?.Cancel();
_cts = new CancellationTokenSource();
```

---

## 八、核心要点总结

### ✅ 关键机制

1. **单实例原则**：只维护一个 `_cancellationTokenSource`
2. **自动取消旧请求**：避免多个请求同时运行
3. **响应片段超时**：30 秒无新片段才超时（不是整体超时）
4. **100ms 轮询间隔**：性能和及时性的最佳平衡
5. **优雅回滚**：取消后恢复输入框，用户可重新发送

### ✅ 安全保证

- 第一次请求不受影响（`?.` 空安全）
- 已完成任务不受影响（只改变内部状态）
- 新旧任务完全独立（Token 互不干扰）
- 多次取消安全（幂等操作）
- 线程安全（原子操作）

### ✅ 用户体验

- 实时取消响应（100ms 内）
- 输入不丢失（回滚恢复）
- 无错误提示（取消是正常操作）
- 避免消息混乱（自动取消旧请求）

---

**文档版本**: 2.0  
**最后更新**: 2024  
**整合自**: 取消机制.md, 取消机制3.md, 取消机制4.md
