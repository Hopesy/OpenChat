# ChatSessionModel 详解

> 会话视图模型的完整实现分析，包含数据绑定、编辑模式和自动同步机制

---

## 一、类的职责定位

`ChatSessionModel` 是左侧会话列表中每个会话项的视图模型，包装数据库实体 `ChatSession`，提供 UI 绑定和交互功能。

```
主界面布局
├── 左侧：会话列表
│   ├── ChatSessionModel #1 (会话 1)
│   ├── ChatSessionModel #2 (会话 2) ← 当前类
│   └── ChatSessionModel #3 (会话 3)
└── 右侧：聊天页面 (ChatPage)
```

---

## 二、核心属性

### 2.1 基础属性

```csharp
// 会话唯一标识符（Guid）
[ObservableProperty] private Guid _id;

// 会话名称（显示在左侧列表中，可编辑）
[ObservableProperty] private string? _name = string.Empty;

// 是否启用聊天上下文（null 表示使用全局配置，true/false 表示会话特定设置）
[ObservableProperty] private bool? _enableChatContext = null;

// 会话专属系统消息列表（每次 API 请求都会添加这些系统消息，优先级高于全局系统消息）
[ObservableProperty] private ObservableCollection<ValueWrapper<string>> _systemMessages = new();
```

### 2.2 编辑状态属性

```csharp
// 是否处于编辑状态（右键点击"编辑"进入编辑模式）
[ObservableProperty]
[NotifyPropertyChangedFor(nameof(IsReadOnly))] // IsEditing 变化时通知 IsReadOnly 更新
private bool _isEditing = false;

// 是否只读（编辑状态的反向属性，用于控制 UI）
public bool IsReadOnly => !IsEditing;
```

### 2.3 关联属性

```csharp
// 关联的数据库实体，用于持久化存储
public ChatSession? Storage { get; set; }

// 获取该会话对应的聊天页面（通过 ChatPageService 缓存管理）
public ChatPage Page => ChatPageService.GetPage(Id);

// 获取该会话对应的聊天页面 ViewModel
public ChatPageViewModel PageViewModel => Page.ViewModel;
```

---

## 三、关键机制

### 3.1 初始化优化机制

```csharp
// 构造函数：从数据库实体创建会话模型
public ChatSessionModel(ChatSession storage)
{
    Storage = storage;
    SetupStorage(storage);
}

// 从数据库实体初始化属性（避免触发 OnPropertyChanged）
private void SetupStorage(ChatSession storage)
{
#pragma warning disable MVVMTK0034
    // 直接赋值私有字段，避免触发属性变化通知（初始化阶段无需同步到数据库）
    _id = storage.Id;
    _name = storage.Name;
    _enableChatContext = storage.EnableChatContext;
    _systemMessages = storage.SystemMessages.WrapCollection(); // 包装为可观察集合
#pragma warning restore MVVMTK0034
}
```

**为什么需要直接赋值私有字段？**

```csharp
// ❌ 错误方式：通过公共属性赋值
Id = storage.Id;            // 触发 OnPropertyChanged
Name = storage.Name;        // 触发 OnPropertyChanged
// 结果：初始化阶段就尝试同步到数据库，造成不必要的 IO 操作

// ✅ 正确方式：直接赋值私有字段
_id = storage.Id;           // 不触发 OnPropertyChanged
_name = storage.Name;       // 不触发 OnPropertyChanged
// 结果：仅初始化，不触发同步
```

### 3.2 自动同步机制

```csharp
// 属性变化时自动同步到数据库
protected override void OnPropertyChanged(PropertyChangedEventArgs e)
{
    base.OnPropertyChanged(e);
    SyncStorage(); // 任何属性变化都触发同步
}

// 同步当前属性到数据库
[RelayCommand]
public void SyncStorage()
{
    if (Storage != null)
    {
        // 使用 record 的 with 语法创建新实例（不可变更新）
        Storage = Storage with
        {
            Name = Name,
            EnableChatContext = EnableChatContext,
            SystemMessages = SystemMessages.UnwrapToArray() // 解包可观察集合为数组
        };
        
        // 保存到数据库
        ChatStorageService.SaveOrUpdateSession(Storage);
    }
}
```

**工作流程**：

```
用户编辑会话名称 "新对话" → "我的会话"
    ↓
Name 属性变化
    ↓
OnPropertyChanged("Name") 触发
    ↓
SyncStorage() 执行
    ↓
Storage = Storage with { Name = "我的会话" }
    ↓
ChatStorageService.SaveOrUpdateSession(Storage)
    ↓
LiteDB 数据库更新
```

**优点**：
- 用户无需手动点击保存
- 编辑后立即持久化，不会丢失数据
- 实现简洁，无需复杂的保存逻辑

**注意**：
- 频繁修改会导致频繁写数据库（可优化为防抖动）

### 3.3 页面缓存关联

```csharp
// 获取该会话对应的聊天页面（通过 ChatPageService 缓存管理）
public ChatPage Page => ChatPageService.GetPage(Id);

// 获取该会话对应的聊天页面 ViewModel
public ChatPageViewModel PageViewModel => Page.ViewModel;
```

**用途**：

```xml
<!-- 在会话列表中显示最后一条消息预览 -->
<TextBlock>
    <Run Text="{Binding PageViewModel.LastMessage.DisplayName}" />
    <Run Text=": " />
    <Run Text="{Binding PageViewModel.LastMessage.SingleLineContent}" />
</TextBlock>
```

**访问路径**：
```
ChatSessionModel
    → PageViewModel (ChatPageViewModel)
        → LastMessage (ChatMessageModel)
            → DisplayName ("Me" / "Bot")
            → SingleLineContent ("你好，世界")
```

---

## 四、编辑模式实现

### 4.1 进入/退出编辑

```csharp
// 进入编辑模式（右键菜单 → 编辑）
[RelayCommand]
public void StartEdit()
{
    IsEditing = true;  // → IsReadOnly = false
}

// 退出编辑模式（失去焦点或按回车键）
[RelayCommand]
public void EndEdit()
{
    IsEditing = false;  // → IsReadOnly = true
    // OnPropertyChanged 自动触发，同步到数据库
}
```

### 4.2 UI 绑定

```xml
<!-- MainPage.xaml 会话标题 TextBox -->
<TextBox 
    Text="{Binding Name, TargetNullValue='新对话'}"
    IsHitTestVisible="{Binding IsEditing}"    ← 控制是否响应鼠标
    IsReadOnly="{Binding IsReadOnly}"         ← 控制是否可编辑
    Background="Transparent"
    BorderThickness="1">
    
    <!-- 失去焦点退出编辑 -->
    <behaviors:Interaction.Triggers>
        <behaviors:EventTrigger EventName="LostFocus">
            <behaviors:InvokeCommandAction Command="{Binding EndEditCommand}" />
        </behaviors:EventTrigger>
    </behaviors:Interaction.Triggers>
    
    <!-- 按回车键退出编辑 -->
    <TextBox.InputBindings>
        <KeyBinding Key="Return" Command="{Binding EndEditCommand}" />
    </TextBox.InputBindings>
    
    <!-- 样式：编辑时显示蓝色边框 -->
    <TextBox.Style>
        <Style TargetType="TextBox">
            <Setter Property="BorderBrush" Value="Transparent" />
            <Style.Triggers>
                <Trigger Property="IsReadOnly" Value="False">
                    <Setter Property="BorderBrush" Value="#569de5" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </TextBox.Style>
</TextBox>
```

### 4.3 IsHitTestVisible 的作用

```csharp
IsHitTestVisible="{Binding IsEditing}"
```

**为什么需要这个属性？**

```
【只读状态】IsEditing = false → IsHitTestVisible = false
用户点击会话项 → TextBox 不响应点击 → 事件冒泡到 ListBoxItem
→ 触发 SelectionChanged → 切换到该会话的聊天页面

【编辑状态】IsEditing = true → IsHitTestVisible = true
用户点击会话项 → TextBox 响应点击 → 获得焦点，可以编辑标题
```

**如果不设置 IsHitTestVisible**：
- 只读状态下点击会话项可能意外激活 TextBox
- 无法正常选中会话（被 TextBox 拦截了点击事件）

### 4.4 完整交互流程

```
【初始状态】
会话标题显示 "新对话"
IsEditing = false
IsReadOnly = true
IsHitTestVisible = false
→ TextBox 显示为普通文本，不可点击编辑

【进入编辑模式】
用户右键 → 点击"编辑"
    ↓
触发 StartEditCommand
    ↓
IsEditing = true
    ↓
IsReadOnly = false（自动计算）
IsHitTestVisible = true
    ↓
TextBox 变为可编辑状态，显示蓝色边框
    ↓
TextBox 自动获得焦点（如果有 FocusManager）

【编辑标题】
用户修改会话标题 "新对话" → "我的会话"
    ↓
双向绑定更新 ChatSessionModel.Name
    ↓
触发 OnPropertyChanged("Name")
    ↓
SyncStorage() 执行
    ↓
实时保存到数据库

【退出编辑模式】
用户按回车键或失去焦点
    ↓
触发 EndEditCommand
    ↓
IsEditing = false
    ↓
IsReadOnly = true
IsHitTestVisible = false
    ↓
TextBox 恢复为只读状态，边框消失
    ↓
显示编辑后的标题 "我的会话"
```

### 4.5 视觉反馈

```
【只读状态】
┌────────────────┐
│ 新对话         │  ← 灰色文本，透明边框
│ Me: 你好       │
└────────────────┘

【编辑状态】
┌────────────────┐
│ [新对话]       │  ← 蓝色边框 (#569de5)，光标闪烁
│ Me: 你好       │
└────────────────┘
```

---

## 五、配置对话框

### 5.1 打开配置对话框

```csharp
// 打开会话配置对话框（右键菜单 → 配置）
[RelayCommand]
public void Config()
{
    // 创建配置对话框（传入当前会话模型）
    var dialog = new ChatSessionConfigDialog(this);
    
    // 设置对话框的父窗口（居中显示）
    if (Application.Current.MainWindow is Window window)
        dialog.Owner = window;
    
    // 显示模态对话框，点击确定后同步到数据库
    if (dialog.ShowDialog() ?? false)
        SyncStorage();
}
```

### 5.2 配置项

**可配置内容**：
1. 会话名称（Name）
2. 是否启用聊天上下文（EnableChatContext）
3. 会话专属系统消息列表（SystemMessages）

**配置对话框示例**：

```
┌─────────────────────────────────┐
│  会话配置                        │
├─────────────────────────────────┤
│  会话名称：                      │
│  ┌─────────────────────────┐   │
│  │ 我的 AI 助手            │   │
│  └─────────────────────────┘   │
│                                 │
│  □ 启用聊天上下文（记忆历史）   │
│                                 │
│  系统消息：                      │
│  ┌─────────────────────────┐   │
│  │ 你是一个helpful助手      │   │
│  │ 你擅长解释技术概念       │   │
│  └─────────────────────────┘   │
│                                 │
│     [取消]        [确定]        │
└─────────────────────────────────┘
```

---

## 六、系统消息优先级

### 6.1 消息列表构建

```csharp
// ChatService.cs - ChatCoreAsync 方法
var messages = new List<Message>();

// 1. 添加全局系统消息（AppConfig.json 配置）
foreach (var sysmsg in ConfigurationService.Configuration.SystemMessages)
    messages.Add(new Message(Role.System, sysmsg));

// 2. 添加会话特定的系统消息（会话设置中配置，优先级更高）
if (session != null)
    foreach (var sysmsg in session.SystemMessages)
        messages.Add(new Message(Role.System, sysmsg));

// 3. 添加历史消息（如果启用上下文）
if (session?.EnableChatContext ?? ConfigurationService.Configuration.EnableChatContext)
    foreach (var chatmsg in ChatStorageService.GetAllMessagesBySession(sessionId))
        messages.Add(new Message(...));

// 4. 添加当前用户消息
messages.Add(new Message(Role.User, message));
```

### 6.2 实际示例

```
【全局配置】
SystemMessages = ["你是一个 AI 助手"]

【会话配置】
SystemMessages = ["你擅长解释技术概念", "请用简洁的语言回答"]

【API 请求时的消息列表】
[System] "你是一个 AI 助手"                    // 全局系统消息
[System] "你擅长解释技术概念"                  // ← 会话系统消息（优先级更高）
[System] "请用简洁的语言回答"                  // ← 会话系统消息
[User]   "什么是依赖注入？"                    // 历史消息
[Assistant] "依赖注入是一种设计模式..."       // 历史消息
[User]   "它有什么好处？"                      // 当前消息
```

### 6.3 EnableChatContext 的三态设计

```csharp
// 是否启用聊天上下文（null 表示使用全局配置，true/false 表示会话特定设置）
[ObservableProperty] private bool? _enableChatContext = null;
```

**三种状态**：

| 值      | 含义                   | 行为                                   |
|---------|------------------------|----------------------------------------|
| `null`  | 使用全局配置           | 读取 `ConfigurationService.Configuration.EnableChatContext` |
| `true`  | 强制启用（会话特定）   | 无论全局如何设置，该会话启用上下文       |
| `false` | 强制禁用（会话特定）   | 无论全局如何设置，该会话禁用上下文       |

**代码实现**：

```csharp
// ChatService.cs
if (session?.EnableChatContext ?? ConfigurationService.Configuration.EnableChatContext)
{
    // 添加历史消息
}

// 等价于：
bool enableContext;
if (session != null && session.EnableChatContext != null)
{
    // 会话有特定设置，使用会话设置
    enableContext = session.EnableChatContext.Value;
}
else
{
    // 会话没有特定设置，使用全局设置
    enableContext = ConfigurationService.Configuration.EnableChatContext;
}
```

---

## 七、数据绑定示例

### 7.1 会话列表绑定

```xml
<!-- MainPage.xaml -->
<ListBox ItemsSource="{Binding AppGlobalData.Sessions}"
         SelectedItem="{Binding AppGlobalData.SelectedSession}">
    
    <!-- 监听选择变化事件 -->
    <behaviors:Interaction.Triggers>
        <behaviors:EventTrigger EventName="SelectionChanged">
            <behaviors:InvokeCommandAction Command="{Binding SwitchPageToCurrentSessionCommand}" />
        </behaviors:EventTrigger>
    </behaviors:Interaction.Triggers>
    
    <!-- 单条数据模板 -->
    <ListBox.ItemTemplate>
        <DataTemplate>
            <!-- 右键菜单 -->
            <DataTemplate.Resources>
                <ContextMenu x:Key="SessionContextMenu">
                    <MenuItem Command="{Binding StartEditCommand}" Header="编辑" />
                    <MenuItem Command="{Binding ConfigCommand}" Header="配置" />
                    <MenuItem Command="..." Header="删除" />
                </ContextMenu>
            </DataTemplate.Resources>
            
            <StackPanel ContextMenu="{StaticResource SessionContextMenu}">
                <!-- 会话名称（可编辑）-->
                <TextBox Text="{Binding Name, TargetNullValue='新对话'}"
                         IsReadOnly="{Binding IsReadOnly}"
                         IsHitTestVisible="{Binding IsEditing}" />
                
                <!-- 最后一条消息预览 -->
                <TextBlock>
                    <Run Text="{Binding PageViewModel.LastMessage.DisplayName}" />
                    <Run Text=": " />
                    <Run Text="{Binding PageViewModel.LastMessage.SingleLineContent}" />
                </TextBlock>
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

### 7.2 数据流向

```
【ViewModel → View】
ChatSessionModel.Name 变化
    ↓
OnPropertyChanged("Name") 触发
    ↓
WPF 数据绑定系统收到通知
    ↓
TextBox.Text 更新显示

【View → ViewModel】
用户在 TextBox 中输入 "我的会话"
    ↓
双向绑定（Mode=TwoWay）
    ↓
ChatSessionModel.Name = "我的会话"
    ↓
OnPropertyChanged 触发
    ↓
SyncStorage() 保存到数据库
```

---

## 八、服务依赖

### 8.1 静态服务定位

```csharp
// 静态服务：聊天页面管理服务（维护会话 ID 到 ChatPage 的缓存字典）
private static ChatPageService ChatPageService { get; } =
    App.GetService<ChatPageService>();

// 静态服务：聊天存储服务（用于自动同步数据到数据库）
private static ChatStorageService ChatStorageService { get; } =
    App.GetService<ChatStorageService>();
```

**为什么使用静态服务？**

```csharp
// ✅ 静态服务定位（当前方案）
private static ChatPageService ChatPageService { get; } = App.GetService<ChatPageService>();

// 优点：
// 1. 所有 ChatSessionModel 实例共享同一个服务实例（单例）
// 2. 无需在构造函数中注入，简化实例化
// 3. 服务在类加载时初始化，性能更好

// ❌ 实例服务注入（备选方案）
private readonly ChatPageService _chatPageService;
public ChatSessionModel(ChatSession storage, ChatPageService chatPageService)
{
    _chatPageService = chatPageService;
    // ...
}

// 缺点：
// 1. 每次创建 ChatSessionModel 都需要传入服务
// 2. 构造函数参数增多，使用复杂
// 3. 依赖注入容器配置复杂
```

### 8.2 服务职责

**ChatPageService**：
- 维护 `Dictionary<Guid, ChatPage>` 缓存
- 通过 `GetPage(sessionId)` 获取或创建聊天页面
- 避免重复创建页面，提升性能

**ChatStorageService**：
- 操作 LiteDB 数据库
- 提供 `SaveOrUpdateSession(session)` 方法
- 处理会话的增删改查

---

## 九、属性包装模式

### 9.1 WrapCollection / UnwrapToArray

```csharp
// 数组 → 可观察集合（初始化时）
_systemMessages = storage.SystemMessages.WrapCollection();

// 可观察集合 → 数组（保存时）
SystemMessages = SystemMessages.UnwrapToArray();
```

**为什么需要包装？**

```csharp
// 数据库实体使用数组（不可变，节省空间）
public record ChatSession
{
    public string[] SystemMessages { get; init; }
}

// ViewModel 使用可观察集合（可变，支持数据绑定）
public class ChatSessionModel
{
    public ObservableCollection<ValueWrapper<string>> SystemMessages { get; set; }
}

// WrapCollection 实现（简化版）
public static ObservableCollection<ValueWrapper<string>> WrapCollection(this string[] array)
{
    var collection = new ObservableCollection<ValueWrapper<string>>();
    foreach (var item in array)
        collection.Add(new ValueWrapper<string>(item));
    return collection;
}

// UnwrapToArray 实现（简化版）
public static string[] UnwrapToArray(this ObservableCollection<ValueWrapper<string>> collection)
{
    return collection.Select(wrapper => wrapper.Value).ToArray();
}
```

**ValueWrapper 的作用**：

```csharp
// 问题：string 是值类型，无法直接绑定到 TextBox 进行编辑
ObservableCollection<string> messages;  // ❌ 修改 TextBox 不会更新集合

// 解决：包装为引用类型
public class ValueWrapper<T>
{
    public T Value { get; set; }  // ✅ 修改 TextBox 会更新 Value 属性
}
ObservableCollection<ValueWrapper<string>> messages;
```

---

## 十、设计模式

### MVVM 模式
- **Model**: `ChatSession`（数据库实体）
- **ViewModel**: `ChatSessionModel`（当前类）
- **View**: `MainPage.xaml` 中的 ListBox ItemTemplate

### 观察者模式
- 继承 `ObservableObject`
- 使用 `[ObservableProperty]` 自动生成属性变化通知
- UI 自动响应数据变化

### 命令模式
- 使用 `[RelayCommand]` 自动生成命令
- 支持 XAML 绑定（如 `Command="{Binding StartEditCommand}"`）

### 服务定位模式
- 使用 `App.GetService<T>()` 获取服务实例
- 解耦 ViewModel 和具体服务实现

---

## 十一、完整生命周期

```
【创建】
MainPage 构造函数
    ↓
从数据库加载所有会话
    ↓
foreach (var session in ChatStorageService.GetAllSessions())
    AppGlobalData.Sessions.Add(new ChatSessionModel(session))
    ↓
ChatSessionModel 构造函数
    ↓
SetupStorage(storage)  // 初始化属性（不触发同步）

【显示】
会话显示在左侧列表
    ↓
数据绑定：Name, PageViewModel.LastMessage

【编辑】
用户右键 → 编辑
    ↓
StartEditCommand 执行
    ↓
IsEditing = true
    ↓
用户修改名称
    ↓
Name 属性变化
    ↓
OnPropertyChanged 触发
    ↓
SyncStorage() 自动保存

【配置】
用户右键 → 配置
    ↓
ConfigCommand 执行
    ↓
显示 ChatSessionConfigDialog
    ↓
用户修改系统消息
    ↓
点击确定
    ↓
SyncStorage() 保存

【删除】
用户右键 → 删除（在 MainPage 中实现）
    ↓
DeleteSessionCommand 执行
    ↓
AppGlobalData.Sessions.Remove(sessionModel)
    ↓
ChatPageService.RemovePage(sessionId)
    ↓
ChatStorageService.DeleteSession(sessionId)
```

---

## 十二、核心要点总结

### ✅ 职责清晰

- 包装数据库实体 `ChatSession`
- 提供 UI 绑定和交互功能
- 管理会话的编辑和配置

### ✅ 自动同步

- 任何属性变化自动保存到数据库
- 无需手动调用保存方法
- 用户体验流畅

### ✅ 页面关联

- 通过 `Page` 和 `PageViewModel` 访问聊天页面
- 在会话列表中显示最后一条消息预览
- 缓存机制提升性能

### ✅ 编辑模式

- 支持会话名称编辑
- 通过 `IsEditing` 和 `IsReadOnly` 控制 UI 状态
- 视觉反馈清晰（蓝色边框）

### ✅ 配置灵活

- 支持会话专属系统消息
- 支持会话级别的上下文开关（三态设计）
- 优先级高于全局配置

### ✅ 性能优化

- 初始化时直接赋值私有字段，避免触发 OnPropertyChanged
- 使用静态服务定位，避免重复创建服务实例
- 页面缓存机制，避免重复创建 ChatPage

---

**文档版本**: 1.0  
**最后更新**: 2024  
**相关文档**: 
- [ChatMessageModel详解](./ChatMessageModel详解.md)（如果存在）
- [ChatPage流程详解](./聊天过程.md)
