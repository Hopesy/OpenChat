# 编辑模式实现详解

> 详细分析 OpenChat 中消息编辑模式的完整实现机制和用户可编辑内容

---

## 一、编辑模式概述

OpenChat 实现了两种编辑模式：
1. **聊天消息编辑**：编辑已发送的聊天消息内容
2. **会话标题编辑**：编辑左侧会话列表中的会话名称

---

## 二、聊天消息编辑模式

### 2.1 触发方式

用户可以通过以下方式进入编辑模式：

#### 方式一：双击消息气泡

```xml
<!-- ChatPage.xaml -->
<controls:ChatBubble ...>
    <behaviors:Interaction.Triggers>
        <!-- 双击进入编辑状态 -->
        <behaviors:EventTrigger EventName="MouseDoubleClick">
            <behaviors:InvokeCommandAction Command="{Binding StartEditCommand}" />
        </behaviors:EventTrigger>
    </behaviors:Interaction.Triggers>
</controls:ChatBubble>
```

#### 方式二：右键菜单

```xml
<!-- ChatPage.xaml -->
<controls:ChatBubble.ContextMenu>
    <ContextMenu>
        <MenuItem Command="{Binding CopyCommand}" Header="复制" />
        <MenuItem Command="{Binding StartEditCommand}" Header="编辑" />  ← 点击进入编辑
        <MenuItem Header="删除">
            <!-- 删除选项 -->
        </MenuItem>
    </ContextMenu>
</controls:ChatBubble.ContextMenu>
```

### 2.2 核心实现机制

#### A. 数据模型层（ChatMessageModel.cs）

```csharp
public partial class ChatMessageModel : ObservableObject
{
    // 【关键属性 1】编辑状态标志
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsReadOnly))]
    private bool _isEditing = false;
    
    // 【关键属性 2】只读状态（编辑状态的反向）
    public bool IsReadOnly => !IsEditing;
    
    // 【命令 1】进入编辑模式
    [RelayCommand]
    public void StartEdit()
    {
        IsEditing = true;  // 触发 IsReadOnly 变为 false
    }
    
    // 【命令 2】退出编辑模式
    [RelayCommand]
    public void EndEdit()
    {
        IsEditing = false;  // 触发 IsReadOnly 变为 true
    }
    
    // 【关键机制】属性变化自动同步到数据库
    protected override void OnPropertyChanged(PropertyChangedEventArgs e)
    {
        base.OnPropertyChanged(e);
        
        // 如果有关联的数据库实体，则将修改同步到数据库
        if (Storage != null)
        {
            // 使用 record 的 with 语法创建新实例（不可变更新）
            Storage = Storage with
            {
                Role = Role,
                Content = Content  // ← 用户编辑后的内容
            };
            
            // 自动保存到数据库
            ChatStorageService.SaveMessage(Storage);
        }
    }
}
```

**工作流程**：
```
用户双击消息气泡
    ↓
触发 StartEditCommand
    ↓
IsEditing = true
    ↓
NotifyPropertyChangedFor 通知 IsReadOnly 变化
    ↓
IsReadOnly = false
    ↓
UI 层的 ChatBubble 收到通知
    ↓
切换到可编辑状态（显示 TextBox）
```

#### B. UI 层（ChatPage.xaml）

```xml
<controls:ChatBubble 
    Content="{Binding Content, Mode=TwoWay}"  ← 双向绑定消息内容
    IsReadonly="{Binding IsReadOnly}"         ← 绑定只读状态
    ... >
    
    <!-- 样式根据 IsReadonly 变化 -->
    <controls:ChatBubble.Style>
        <Style TargetType="controls:ChatBubble">
            <Setter Property="HeaderForeground" Value="Gray" />
            <Setter Property="BorderBrush" Value="{DynamicResource ChatBubbleBorder}" />
            <Style.Triggers>
                <!-- 非只读状态（编辑中）显示蓝色边框 -->
                <Trigger Property="IsReadonly" Value="False">
                    <Setter Property="HeaderForeground" Value="#569de5" />
                    <Setter Property="BorderBrush" Value="#569de5" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </controls:ChatBubble.Style>
    
    <behaviors:Interaction.Triggers>
        <!-- 失去焦点退出编辑状态 -->
        <behaviors:EventTrigger EventName="LostFocus">
            <behaviors:InvokeCommandAction Command="{Binding EndEditCommand}" />
        </behaviors:EventTrigger>
    </behaviors:Interaction.Triggers>
</controls:ChatBubble>
```

#### C. 控件层（ChatBubble.cs）

```csharp
public class ChatBubble : Control
{
    // 依赖属性：消息内容（支持双向绑定）
    public static readonly DependencyProperty ContentProperty =
        DependencyProperty.Register(
            nameof(Content), 
            typeof(string), 
            typeof(ChatBubble), 
            new PropertyMetadata(string.Empty));
    
    public string Content
    {
        get { return (string)GetValue(ContentProperty); }
        set { SetValue(ContentProperty, value); }
    }
    
    // 依赖属性：是否只读
    public static readonly DependencyProperty IsReadonlyProperty =
        DependencyProperty.Register(
            nameof(IsReadonly), 
            typeof(bool), 
            typeof(ChatBubble), 
            new PropertyMetadata(true));  // 默认只读
    
    public bool IsReadonly
    {
        get { return (bool)GetValue(IsReadonlyProperty); }
        set { SetValue(IsReadonlyProperty, value); }
    }
}
```

### 2.3 完整交互流程

```
【初始状态】
ChatMessageModel.IsEditing = false
ChatMessageModel.IsReadOnly = true
ChatBubble.IsReadonly = true
→ 消息显示为只读的 Markdown 视图

【进入编辑模式】
用户双击消息气泡
    ↓
触发 StartEditCommand
    ↓
IsEditing = true
    ↓
IsReadOnly = false（自动计算属性）
    ↓
ChatBubble.IsReadonly = false（数据绑定更新）
    ↓
【控件模板切换】
在 Generic.xaml 中的 ChatBubble 模板根据 IsReadonly 属性
从 MarkdownViewer（只读）切换到 TextBox（可编辑）
    ↓
TextBox 获得焦点，用户可以编辑内容

【编辑内容】
用户修改 TextBox 内容
    ↓
双向绑定更新 ChatMessageModel.Content
    ↓
触发 OnPropertyChanged
    ↓
自动同步到 Storage（数据库实体）
    ↓
调用 ChatStorageService.SaveMessage(Storage)
    ↓
内容实时保存到数据库

【退出编辑模式】
用户点击其他地方（失去焦点）或按 Esc
    ↓
触发 EndEditCommand
    ↓
IsEditing = false
    ↓
IsReadOnly = true
    ↓
ChatBubble.IsReadonly = true
    ↓
【控件模板切换】
从 TextBox（可编辑）切换回 MarkdownViewer（只读）
    ↓
显示编辑后的内容（已保存到数据库）
```

### 2.4 视觉反馈

```
【只读状态】
┌─────────────────────┐
│ Me: 你好             │  ← 灰色标题
│                     │
│ 这是消息内容...      │  ← Markdown 渲染
│                     │
└─────────────────────┘
  灰色边框

【编辑状态】
┌─────────────────────┐
│ Me: 你好             │  ← 蓝色标题 (#569de5)
│                     │
│ [这是消息内容...]    │  ← TextBox 可编辑
│  ▊                  │  ← 光标闪烁
└─────────────────────┘
  蓝色边框 (#569de5)
```

---

## 三、会话标题编辑模式

### 3.1 触发方式

用户可以通过以下方式编辑会话标题：

#### 方式一：右键菜单

```xml
<!-- MainPage.xaml -->
<ContextMenu x:Key="SessionContextMenu">
    <MenuItem Command="{Binding StartEditCommand}" Header="编辑" />  ← 点击进入编辑
    <MenuItem Command="{Binding ConfigCommand}" Header="配置" />
    <MenuItem Command="..." Header="删除" />
</ContextMenu>
```

### 3.2 实现机制

#### A. 数据模型层（ChatSessionModel.cs）

```csharp
public partial class ChatSessionModel : ObservableObject
{
    // 会话名称（可编辑）
    [ObservableProperty]
    private string _name = string.Empty;
    
    // 编辑状态
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsReadOnly))]
    private bool _isEditing = false;
    
    // 只读状态
    public bool IsReadOnly => !IsEditing;
    
    // 进入编辑模式
    [RelayCommand]
    public void StartEdit()
    {
        IsEditing = true;
    }
    
    // 退出编辑模式
    [RelayCommand]
    public void EndEdit()
    {
        IsEditing = false;
        // 保存到数据库
        ChatStorageService.SaveOrUpdateSession(Storage);
    }
}
```

#### B. UI 层（MainPage.xaml）

```xml
<!-- 会话标题 TextBox -->
<TextBox 
    Text="{Binding Name, TargetNullValue='新对话'}"
    IsHitTestVisible="{Binding IsEditing}"    ← 控制是否可交互
    IsReadOnly="{Binding IsReadOnly}"         ← 控制是否可编辑
    Background="Transparent"
    BorderThickness="1">
    
    <!-- 失去焦点退出编辑 -->
    <behaviors:Interaction.Triggers>
        <behaviors:EventTrigger EventName="LostFocus">
            <behaviors:InvokeCommandAction Command="{Binding EndEditCommand}" />
        </behaviors:EventTrigger>
    </behaviors:Interaction.Triggers>
    
    <!-- 按回车键退出编辑 -->
    <TextBox.InputBindings>
        <KeyBinding Key="Return" Command="{Binding EndEditCommand}" />
    </TextBox.InputBindings>
    
    <!-- 样式：编辑时显示蓝色边框 -->
    <TextBox.Style>
        <Style TargetType="TextBox">
            <Setter Property="BorderBrush" Value="Transparent" />
            <Style.Triggers>
                <Trigger Property="IsReadOnly" Value="False">
                    <Setter Property="BorderBrush" Value="#569de5" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </TextBox.Style>
</TextBox>
```

### 3.3 关键属性说明

#### IsHitTestVisible vs IsReadOnly

```csharp
// IsHitTestVisible：控制是否响应鼠标事件
IsHitTestVisible="{Binding IsEditing}"
// IsEditing = false → IsHitTestVisible = false → TextBox 不响应点击
// IsEditing = true  → IsHitTestVisible = true  → TextBox 可以点击选中

// IsReadOnly：控制是否可以编辑内容
IsReadOnly="{Binding IsReadOnly}"
// IsReadOnly = true  → 内容只读，无法修改
// IsReadOnly = false → 内容可编辑
```

**为什么需要两个属性？**

```
【只读状态】
IsEditing = false
IsReadOnly = true
IsHitTestVisible = false
→ 用户点击会话项时，不会激活 TextBox 的编辑功能
→ 点击会选中整个会话项（触发 SelectionChanged）

【编辑状态】
IsEditing = true
IsReadOnly = false
IsHitTestVisible = true
→ TextBox 可以响应点击和输入
→ 用户可以修改会话标题
```

### 3.4 完整交互流程

```
【初始状态】
会话标题显示为普通文本，不可编辑

【进入编辑模式】
用户右键 → 点击"编辑"
    ↓
触发 StartEditCommand
    ↓
IsEditing = true
    ↓
IsReadOnly = false
IsHitTestVisible = true
    ↓
TextBox 变为可编辑状态，显示蓝色边框
    ↓
TextBox 自动获得焦点（如果有 FocusManager）

【编辑标题】
用户修改会话标题
    ↓
双向绑定更新 ChatSessionModel.Name
    ↓
触发 OnPropertyChanged
    ↓
UI 实时更新显示

【退出编辑模式】
用户按回车键或失去焦点
    ↓
触发 EndEditCommand
    ↓
IsEditing = false
    ↓
IsReadOnly = true
IsHitTestVisible = false
    ↓
保存到数据库
    ↓
TextBox 恢复为只读状态，边框消失
```

---

## 四、用户可编辑的内容总结

### 4.1 聊天消息内容

**可编辑内容**：
- ✅ 用户发送的消息内容
- ✅ AI 助手的回复内容
- ✅ 支持多行文本编辑
- ✅ 支持 Markdown 格式（编辑后以 Markdown 渲染）

**编辑方式**：
- 双击消息气泡
- 右键菜单 → 编辑

**保存时机**：
- 实时保存（每次 Content 属性变化都自动同步到数据库）

**限制**：
- ❌ 不能编辑消息角色（Role: "user" 或 "assistant"）
- ❌ 不能编辑消息时间戳

### 4.2 会话标题

**可编辑内容**：
- ✅ 会话名称（Name 属性）
- ✅ 单行文本

**编辑方式**：
- 右键会话项 → 编辑

**保存时机**：
- 失去焦点时保存
- 按回车键时保存

**限制**：
- ❌ 不能编辑会话 ID
- ❌ 不能编辑会话创建时间

### 4.3 其他可编辑内容

根据代码分析，以下内容也可能支持编辑（需要具体实现）：

1. **会话系统消息**（Session.SystemMessages）
   - 通过会话配置对话框编辑

2. **全局系统消息**（Configuration.SystemMessages）
   - 通过配置页面编辑

3. **API 配置**
   - API Key
   - API Host
   - Model Name
   - Temperature

---

## 五、关键技术点

### 5.1 双向绑定

```xml
<!-- TwoWay 模式确保：-->
<!-- UI → ViewModel：用户编辑时自动更新 ViewModel -->
<!-- ViewModel → UI：ViewModel 变化时自动更新 UI -->
<controls:ChatBubble Content="{Binding Content, Mode=TwoWay}" />
```

### 5.2 属性通知链

```csharp
[ObservableProperty]
[NotifyPropertyChangedFor(nameof(IsReadOnly))]  // ← 关键特性
private bool _isEditing = false;

public bool IsReadOnly => !IsEditing;  // ← 计算属性

// 工作原理：
// IsEditing 变化 → 触发 PropertyChanged("IsEditing")
//                 → 同时触发 PropertyChanged("IsReadOnly")
//                 → UI 收到 IsReadOnly 变化通知
//                 → 更新绑定的控件状态
```

### 5.3 自动保存机制

```csharp
protected override void OnPropertyChanged(PropertyChangedEventArgs e)
{
    base.OnPropertyChanged(e);
    
    // 任何属性变化都会触发此方法
    if (Storage != null)
    {
        // 使用 record 的 with 语法创建新实例
        Storage = Storage with
        {
            Role = Role,
            Content = Content  // ← 自动同步最新内容
        };
        
        // 立即保存到数据库
        ChatStorageService.SaveMessage(Storage);
    }
}
```

**优点**：
- 无需手动调用保存方法
- 用户编辑后立即持久化，不会丢失数据
- 支持实时协作（如果扩展为多端同步）

**注意**：
- 频繁保存可能影响性能（当前实现每次属性变化都保存）
- 可以优化为防抖动（Debounce）保存

### 5.4 视觉反馈

```xml
<Style.Triggers>
    <!-- 编辑状态用蓝色边框和标题突出显示 -->
    <Trigger Property="IsReadonly" Value="False">
        <Setter Property="HeaderForeground" Value="#569de5" />
        <Setter Property="BorderBrush" Value="#569de5" />
    </Trigger>
</Style.Triggers>
```

**用户体验**：
- 清晰区分编辑状态和只读状态
- 蓝色是常见的编辑/激活状态颜色
- 边框和标题同时变色，视觉一致性好

---

## 六、扩展可能性

### 6.1 撤销/重做功能

```csharp
// 可以在 OnPropertyChanged 中记录历史
private Stack<string> _undoStack = new Stack<string>();
private Stack<string> _redoStack = new Stack<string>();

protected override void OnPropertyChanged(PropertyChangedEventArgs e)
{
    if (e.PropertyName == nameof(Content))
    {
        _undoStack.Push(Content);
        _redoStack.Clear();
    }
    base.OnPropertyChanged(e);
}

[RelayCommand]
public void Undo()
{
    if (_undoStack.Count > 0)
    {
        _redoStack.Push(Content);
        Content = _undoStack.Pop();
    }
}
```

### 6.2 Markdown 实时预览

```xml
<!-- 分屏显示：左侧编辑，右侧预览 -->
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    
    <TextBox Grid.Column="0" Text="{Binding Content, UpdateSourceTrigger=PropertyChanged}" />
    <controls:MarkdownViewer Grid.Column="1" Content="{Binding Content}" />
</Grid>
```

### 6.3 协作编辑

```csharp
// 添加版本号和锁定机制
public record ChatMessage
{
    public Guid Id { get; init; }
    public string Content { get; init; }
    public int Version { get; init; }  // 版本号
    public string? LockedBy { get; init; }  // 锁定者
}

// 编辑前检查锁定状态
[RelayCommand]
public void StartEdit()
{
    if (Storage?.LockedBy != null && Storage.LockedBy != CurrentUserId)
    {
        NoteService.Show("该消息正在被其他用户编辑");
        return;
    }
    
    // 锁定消息
    Storage = Storage with { LockedBy = CurrentUserId };
    ChatStorageService.SaveMessage(Storage);
    
    IsEditing = true;
}
```

---

## 七、最佳实践建议

### 7.1 性能优化

```csharp
// 使用防抖动避免频繁保存
private DispatcherTimer _saveTimer;

protected override void OnPropertyChanged(PropertyChangedEventArgs e)
{
    base.OnPropertyChanged(e);
    
    if (Storage != null && e.PropertyName == nameof(Content))
    {
        // 延迟 500ms 保存
        _saveTimer?.Stop();
        _saveTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(500) };
        _saveTimer.Tick += (s, args) =>
        {
            _saveTimer.Stop();
            ChatStorageService.SaveMessage(Storage);
        };
        _saveTimer.Start();
    }
}
```

### 7.2 用户体验

```csharp
// 添加编辑确认对话框（针对重要消息）
[RelayCommand]
public async Task EndEdit()
{
    if (IsImportantMessage && HasUnsavedChanges)
    {
        var result = await DialogService.ShowConfirmAsync(
            "确认保存修改吗？",
            "取消", "保存");
        
        if (result == false)
        {
            // 恢复原始内容
            Content = _originalContent;
        }
    }
    
    IsEditing = false;
}
```

### 7.3 错误处理

```csharp
protected override void OnPropertyChanged(PropertyChangedEventArgs e)
{
    base.OnPropertyChanged(e);
    
    if (Storage != null)
    {
        try
        {
            Storage = Storage with { Content = Content };
            ChatStorageService.SaveMessage(Storage);
        }
        catch (Exception ex)
        {
            NoteService.Show($"保存失败: {ex.Message}");
            // 记录日志
            Logger.Error(ex, "Failed to save message");
        }
    }
}
```

---

**文档版本**: 1.0  
**最后更新**: 2024  
**相关文档**: 
- [ChatPage流程详解.md](./ChatPage流程详解.md)
- [ChatMessageModel 实现分析](../Models/ChatMessageModel.cs)
